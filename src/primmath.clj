;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
;   which can be found in the file CPL.TXT at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(in-ns 'int)
(clojure/refer 'clojure :exclude '(+ - * / == < <= > >= zero? pos? neg? inc dec array max min))
(import '(clojure.lang Numbers$I))

(definline + [x y] `(. Numbers$I add ~x ~y))
(definline - [x y] `(. Numbers$I subtract ~x ~y))
(definline * [x y] `(. Numbers$I multiply ~x ~y))
(definline div [x y] `(. Numbers$I divide ~x ~y))
(definline == [x y] `(. Numbers$I equiv ~x ~y))
(definline < [x y] `(. Numbers$I lt ~x ~y))
(definline <= [x y] `(. Numbers$I lte ~x ~y))
(definline > [x y] `(. Numbers$I gt ~x ~y))
(definline >= [x y] `(. Numbers$I gte ~x ~y))
(definline zero? [x] `(. Numbers$I zero ~x))
(definline pos? [x] `(. Numbers$I pos ~x))
(definline neg? [x] `(. Numbers$I neg ~x))
(definline inc [x] `(. Numbers$I inc ~x))
(definline dec [x] `(. Numbers$I dec ~x))
(definline negate [x] `(. Numbers$I negate ~x))

(definline array [size init] `(. Numbers$I array ~size ~init))
(definline vsadd [xs y] `(. Numbers$I vsadd ~xs ~y))
(definline vssub [xs y] `(. Numbers$I vssub ~xs ~y))
(definline vsdiv [xs y] `(. Numbers$I vsdiv ~xs ~y))
(definline vsmul [xs y] `(. Numbers$I vsmul ~xs ~y))
(definline svdiv [x ys] `(. Numbers$I svdiv ~x ~ys))

(definline vsmuladd [xs y zs] `(. Numbers$I vsmuladd ~xs ~y ~zs))
(definline vsmulsub [xs y zs] `(. Numbers$I vsmulsub ~xs ~y ~zs))
(definline vsmulsadd [xs y z] `(. Numbers$I vsmuladd ~xs ~y ~z))
(definline vsmulssub [xs y z] `(. Numbers$I vsmulssub ~xs ~y ~z))

(definline vabs [xs] `(. Numbers$I vabs ~xs))
(definline vnegabs [xs] `(. Numbers$I vnegabs ~xs))
(definline vneg [xs] `(. Numbers$I vneg ~xs))
(definline vsqr [xs] `(. Numbers$I vsqr ~xs))
(definline vsignedsqr [xs] `(. Numbers$I vsignedsqr ~xs))
(definline vreverse [xs] `(. Numbers$I vreverse ~xs))
(definline vrunningsum [xs] `(. Numbers$I vrunningsum ~xs))
(definline vsort [xs] `(. Numbers$I vsort ~xs))
(definline vmax [xs] `(. Numbers$I vmax ~xs))
(definline vmin [xs] `(. Numbers$I vmin ~xs))
(definline vmean [xs] `(. Numbers$I vmean ~xs))
(definline vrms [xs] `(. Numbers$I vrms ~xs))
(definline vsum [xs] `(. Numbers$I vsum ~xs))

(definline vclip [xs low high] `(. Numbers$I vclip ~xs ~low ~high))
(definline vclipcounts [xs low high] `(. Numbers$I vclipcounts ~xs ~low ~high))
(definline vthresh [xs thresh otherwise] `(. Numbers$I vthresh ~xs ~thresh ~otherwise))

(definline vdot [xs ys] `(. Numbers$I vdot ~xs ~ys))

(in-ns 'long)
(clojure/refer 'clojure :exclude '(+ - * / == < <= > >= zero? pos? neg? inc dec array))
(import '(clojure.lang Numbers$L))

(definline + [x y] `(. Numbers$L add ~x ~y))
(definline - [x y] `(. Numbers$L subtract ~x ~y))
(definline * [x y] `(. Numbers$L multiply ~x ~y))
(definline div [x y] `(. Numbers$L divide ~x ~y))
(definline == [x y] `(. Numbers$L equiv ~x ~y))
(definline < [x y] `(. Numbers$L lt ~x ~y))
(definline <= [x y] `(. Numbers$L lte ~x ~y))
(definline > [x y] `(. Numbers$L gt ~x ~y))
(definline >= [x y] `(. Numbers$L gte ~x ~y))
(definline zero? [x] `(. Numbers$L zero ~x))
(definline pos? [x] `(. Numbers$L pos ~x))
(definline neg? [x] `(. Numbers$L neg ~x))
(definline inc [x] `(. Numbers$L inc ~x))
(definline dec [x] `(. Numbers$L dec ~x))
(definline negate [x] `(. Numbers$L negate ~x))

(in-ns 'float)
(clojure/refer 'clojure :exclude '(+ - * / == < <= > >= zero? pos? neg? inc dec array))
(import '(clojure.lang Numbers$F))

(definline + [x y] `(. Numbers$F add ~x ~y))
(definline - [x y] `(. Numbers$F subtract ~x ~y))
(definline * [x y] `(. Numbers$F multiply ~x ~y))
(definline div [x y] `(. Numbers$F divide ~x ~y))
(definline == [x y] `(. Numbers$F equiv ~x ~y))
(definline < [x y] `(. Numbers$F lt ~x ~y))
(definline <= [x y] `(. Numbers$F lte ~x ~y))
(definline > [x y] `(. Numbers$F gt ~x ~y))
(definline >= [x y] `(. Numbers$F gte ~x ~y))
(definline zero? [x] `(. Numbers$F zero ~x))
(definline pos? [x] `(. Numbers$F pos ~x))
(definline neg? [x] `(. Numbers$F neg ~x))
(definline inc [x] `(. Numbers$F inc ~x))
(definline dec [x] `(. Numbers$F dec ~x))
(definline negate [x] `(. Numbers$F negate ~x))

(in-ns 'double)
(clojure/refer 'clojure :exclude '(+ - * / == < <= > >= zero? pos? neg? inc dec array))
(import '(clojure.lang Numbers$D))

(definline + [x y] `(. Numbers$D add ~x ~y))
(definline - [x y] `(. Numbers$D subtract ~x ~y))
(definline * [x y] `(. Numbers$D multiply ~x ~y))
(definline div [x y] `(. Numbers$D divide ~x ~y))
(definline == [x y] `(. Numbers$D equiv ~x ~y))
(definline < [x y] `(. Numbers$D lt ~x ~y))
(definline <= [x y] `(. Numbers$D lte ~x ~y))
(definline > [x y] `(. Numbers$D gt ~x ~y))
(definline >= [x y] `(. Numbers$D gte ~x ~y))
(definline zero? [x] `(. Numbers$D zero ~x))
(definline pos? [x] `(. Numbers$D pos ~x))
(definline neg? [x] `(. Numbers$D neg ~x))
(definline inc [x] `(. Numbers$D inc ~x))
(definline dec [x] `(. Numbers$D dec ~x))
(definline negate [x] `(. Numbers$D negate ~x))
