/**
 *   Copyright (c) Rich Hickey. All rights reserved.
 *   The use and distribution terms for this software are covered by the
 *   Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
 *   which can be found in the file CPL.TXT at the root of this distribution.
 *   By using this software in any fashion, you are agreeing to be bound by
 * 	 the terms of this license.
 *   You must not remove this notice, or any other, from this software.
 **/

/* rich Sep 3, 2006 */

package clojure.lang;

import java.io.StringWriter;
import java.io.InputStreamReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class Compiler{
///*
static Symbol DEF = Symbol.intern("def");
static Symbol FN = Symbol.intern("fn");
static Symbol DO = Symbol.intern("do");
static Symbol IF = Symbol.intern("if");
static Symbol IMPORT = Symbol.intern("import");
static Symbol USE = Symbol.intern("use");
static Symbol _AM_KEY = Symbol.intern("&key");
static Symbol _AM_REST = Symbol.intern("&rest");

static public Var _CT_OUT = RT.OUT;
static public Var _CT_MODULE = RT._CT_MODULE;

static NilExpr NIL_EXPR = new NilExpr();

//short-name-string->full-name-string
static public Var IMPORTS = Module.intern("clojure", "^compiler-imports");
//keyword->keywordexpr
static public Var KEYWORDS = Module.intern("clojure", "^compiler-keywords");
//var->var
static public Var VARS = Module.intern("clojure", "^compiler-vars");
//symbol->localbinding
static public Var LOCAL_ENV = Module.intern("clojure", "^compiler-local-env");
//FnFrame
static public Var METHOD = Module.intern("clojure", "^compiler-method");
//module->module
static public Var USES = Module.intern("clojure", "^compiler-uses");
//ISeq FnExprs
static public Var FNS = Module.intern("clojure", "^compiler-fns");

static public  IPersistentMap CHAR_MAP =
        new PersistentArrayMap('-', "_HY_",
                               '.', "_DT_",
                               ':', "_CL_",
                               '+', "_PL_",
                               '>', "_GT_",
                               '<', "_LT_",
                               '=', "_EQ_",
                               '~', "_TL_",
                               '!', "_EP_",
                               '@', "_AT_",
                               '#', "_SH_",
                               '$', "_DS_",
                               '%', "_PT_",
                               '^', "_CT_",
                               '&', "_AM_",
                               '*', "_ST_",
                               '{', "_LB_",
                               '}', "_RB_",
                               '[', "_LK_",
                               ']', "_RK_",
                               '/', "_SL_",
                               '\\',"_BS_",
                               '?', "_QM_");

private static final int MAX_POSITIONAL_ARITY = 20;


static String compile(String ns, String className, LineNumberingPushbackReader... files) throws Exception {
    StringWriter w = new StringWriter();
    try
        {
        _CT_OUT.pushThreadBinding(w);
        KEYWORDS.pushThreadBinding(null);
        VARS.pushThreadBinding(null);
        METHOD.pushThreadBinding(null);
        LOCAL_ENV.pushThreadBinding(null);
        FNS.pushThreadBinding(new PersistentArrayList(4));

        format("/* Generated by Clojure */~%~%");
        format("package ~A;~%", ns);
        format("import clojure.lang.*;~%~%");
        format("public class ~A{~%", className);

        PersistentArrayList forms = new PersistentArrayList(20);
        for(LineNumberingPushbackReader reader : files)
            {
            try
                {
                IMPORTS.pushThreadBinding(null);
                USES.pushThreadBinding(null);

                Object eof = new Object();
                Object form = null;

                while((form = LispReader.read(reader,false,eof,false)) != eof)
                    {
                    form = macroexpand(form);
                    if(!(form instanceof ISeq))
                        throw new Exception("No atoms allowed at top level");
                    Object op = RT.first(form);

                    //enact import and use at compile-time
                    if(op == IMPORT)
                        {
                        //todo implement import
                        }
                    else if(op == USE)
                        {
                        //todo implement use
                        }
                    else
                        forms = forms.cons(analyze(C.STATEMENT, form));
                    }
                }
            finally
                {
                IMPORTS.popThreadBinding();
                USES.popThreadBinding();
                }
            }
        //declare static members for keywords, vars
        for(ISeq keys = RT.seq(KEYWORDS.getValue());keys != null;keys = keys.rest())
            {
            KeywordExpr k = (KeywordExpr) ((IMapEntry) keys.first()).val();
            format("static Keyword ~A;~%", k.emitExpressionString());
            }
        for(ISeq vars = RT.seq(VARS.getValue());vars != null;vars = vars.rest())
            {
            Var v = (Var) ((IMapEntry) vars.first()).val();
            format("static Var ~A;~%", munge(v.toString()));
            }

        //todo declare static members for syms, quoted aggregates

        //emit nested static class/method declarations for nested fns
        PersistentArrayList fns = (PersistentArrayList)FNS.getValue();
        for(int f =0;f<fns.count();f++)
            {
            FnExpr fn = (FnExpr) fns.nth(f);
            fn.emitDeclaration();
            }

        //define the load function
        format("public void load() throws Exception{~%");
            //init the keywords and vars
            for(ISeq keys = RT.seq(KEYWORDS.getValue());keys != null;keys = keys.rest())
                {
                KeywordExpr k = (KeywordExpr) ((IMapEntry) keys.first()).val();
                format("~A = (Keyword)Symbol.intern(~S);~%", k.emitExpressionString(), k.sym.name);
                }
            for(ISeq vars = RT.seq(VARS.getValue());vars != null;vars = vars.rest())
                {
                Var v = (Var) ((IMapEntry) vars.first()).val();
                format("~A = Module.intern(~S,~S);~%", munge(v.toString()), v.module.name,v.name.name);
                }
            //todo init syms and quoted aggregates
            //emit the top level forms
            for(int i = 0;i<forms.count();i++)
                {
                Expr e = (Expr) forms.nth(i);
                e.emitStatement();
                }
        //close load function
        format("}~%");

        //close class def
        format("}~%");
        }
    catch(Exception e)
        {
        e.printStackTrace();
        }
    finally
        {
        _CT_OUT.popThreadBinding();
        KEYWORDS.popThreadBinding();
        VARS.popThreadBinding();
        METHOD.popThreadBinding();
        LOCAL_ENV.popThreadBinding();
        FNS.popThreadBinding();
        }
    return w.toString();
}

static String munge(String name){
    StringBuilder sb = new StringBuilder();
    for(char c : name.toCharArray())
        {
        String sub = (String) CHAR_MAP.get(c);
        if(sub != null)
            sb.append(sub);
        else
            sb.append(c);
        }
    return sb.toString();
}

enum C{STATEMENT,EXPRESSION,RETURN}

interface Expr{

    void emitReturn() throws Exception;

    void emitStatement() throws Exception;

    void emitExpression() throws Exception;

    String emitExpressionString() throws Exception;
}

static void format(String str,Object... args) throws Exception {
    RT.format(RT.T, str, args);
}

static class AnExpr implements Expr{

    public void emitReturn() throws Exception{
        format("return ");
        emitExpression();
        format(";~%");
    }

    public void emitStatement() throws Exception{
        emitExpression();
        format(";~%");
    }

    public void emitExpression() throws Exception{
        throw new UnsupportedOperationException();
    }

    public String emitExpressionString() throws Exception {
        StringWriter w = new StringWriter();
        try{
            _CT_OUT.pushThreadBinding(w);
            emitExpression();
            return w.toString();
        }
        finally{
            _CT_OUT.popThreadBinding();
        }
    }
}

public static void processForm(Object form) throws Exception{
    if(RT.first(form) == DEF)
        {
        convert(form);
        }
    else
        throw new UnsupportedOperationException();
}

private static void convert(Object form) throws Exception{
    Expr e = analyze(C.STATEMENT, form);
}

private static Expr analyze(C context, Object form) throws Exception {
    if(form == null)
        return NIL_EXPR;
    else if(form instanceof Symbol)
        return analyzeSymbol((Symbol) form);
    else if(form instanceof ISeq)
        return analyzeSeq(context, (ISeq) form);
    else if(form instanceof Num || form instanceof String)
        return new LiteralExpr(form);
    else if(form instanceof Character)
        return new CharExpr((Character)form);
    else
        throw new UnsupportedOperationException();
}

private static Expr analyzeSeq(C context, ISeq form) throws Exception {
    Object op = RT.first(form);
    if(op == DEF)
        return analyzeDef(context, form);
    else if(op == FN)
        return analyzeFn(context, form);
    else if(op == DO)
        return analyzeDo(context, form);
    else if(op == IF)
        return analyzeIf(context, form);
    else
        throw new UnsupportedOperationException();
}

private static Expr analyzeIf(C context, ISeq form) throws Exception {
    //(if test then) or (if test then else)
    if(RT.second(form) == RT.T) //optimize macro-generated (if :t ...) forms
        return analyze(context,macroexpand(RT.third(form)));
    else if(RT.second(form) == null)
        return analyze(context,macroexpand(RT.fourth(form)));
    Expr testExpr = analyze(C.EXPRESSION, macroexpand(RT.second(form)));
    String compare = "!=";
    //lift tests that are not exprs by taking value as test and inverting compare
    if(testExpr instanceof NotExpr)
        {
        testExpr = ((NotExpr)testExpr).expr;
        compare = "==";
        }
    return new IfExpr(testExpr, compare, analyze(context, macroexpand(RT.third(form))),
                      analyze(context, macroexpand(RT.fourth(form))));
}

private static Expr analyzeDo(C context, ISeq form) throws Exception {
    //(do ...)
    //(do) == null
    if(RT.rest(form) == null)
        return NIL_EXPR;
    else if(RT.rest(RT.rest(form)) == null) //(do x) == x
        return analyze(context, macroexpand(RT.second(form)));
    else if(context == C.EXPRESSION)
        return analyzeFn(context, RT.list(RT.cons(FN, RT.cons(null, RT.rest(form)))));
    else
        return analyzeBody(context, RT.rest(form));

}

static class IfExpr extends AnExpr{
    final Expr testExpr;
    final String compare;
    final Expr thenExpr;
    final Expr elseExpr;

    public IfExpr(Expr testExpr, String compare, Expr thenExpr, Expr elseExpr) {
        this.testExpr = testExpr;
        this.compare = compare;
        this.thenExpr = thenExpr;
        this.elseExpr = elseExpr;
    }

    public void emitReturn() throws Exception {
        format("if(~A ~A null)~%", testExpr.emitExpressionString(),compare);
        thenExpr.emitReturn();
        format("else~%");
        elseExpr.emitReturn();
    }

    public void emitStatement() throws Exception {
        format("if(~A ~A null)~%", testExpr.emitExpressionString(),compare);
        thenExpr.emitStatement();
        if(!(elseExpr instanceof NilExpr))
            {
            format("~%else~%");
            elseExpr.emitStatement();
            }
    }

    public void emitExpression() throws Exception {
        format("(~A ~A null?", testExpr.emitExpressionString(),compare);
        thenExpr.emitExpression();
        format(":");
        elseExpr.emitExpression();
        format(")");
    }
}
private static Expr analyzeBody(C context, ISeq forms) throws Exception {
    PersistentArrayList exprs = new PersistentArrayList(4);
    for(;forms != null;forms = forms.rest())
        {
        Expr e = (context == C.STATEMENT || RT.rest(forms) != null) ?
                 analyze(C.STATEMENT, macroexpand(forms.first()))
                :
                analyze(C.RETURN, macroexpand(forms.first()));
        exprs = exprs.cons(e);
        }
    return new BodyExpr(exprs);
}

static class BodyExpr extends AnExpr{
    PersistentArrayList exprs;

    public BodyExpr(PersistentArrayList exprs){
        this.exprs = exprs;
    }

    public void emitStatement() throws Exception{
        for(int i=0;i<exprs.count();i++)
            ((Expr)exprs.nth(i)).emitStatement();
    }
    public void emitReturn() throws Exception{
        if(exprs.count() == 0)
            NIL_EXPR.emitReturn();
        else
            {
            for(int i=0;i<exprs.count();i++)
                {
                if(i < exprs.count()-1)
                    ((Expr)exprs.nth(i)).emitStatement();
                else
                    ((Expr)exprs.nth(i)).emitReturn();
                }
            }
    }
}

private static Expr analyzeFn(C context, ISeq form) throws Exception {
    //(fn (args) body) or (fn ((args) body) ((args2) body2) ...)
    //turn former into latter
    if(RT.second(form) == null ||
                 !(RT.first(RT.second(form)) == null || RT.first(RT.second(form)) instanceof ISeq))
        form = RT.list(FN, RT.rest(form));

    FnMethod[] methodArray = new FnMethod[MAX_POSITIONAL_ARITY+1];
    FnMethod variadicMethod = null;
    FnExpr fn = new FnExpr();
    for(ISeq s = RT.rest(form);s != null;s = RT.rest(s))
        {
        FnMethod f = analyzeMethod(fn,(ISeq) RT.first(s));
        if(f.isVariadic())
            {
            if(variadicMethod == null)
                variadicMethod = f;
            else
                throw new Exception("Can't have more than 1 variadic overload");
            }
        else if(methodArray[f.reqParms.count()] == null)
            methodArray[f.reqParms.count()] = f;
        else
            throw new Exception("Can't have 2 overloads with same arity");
        }
    if(variadicMethod != null)
        {
        for(int i = variadicMethod.reqParms.count() + 1;i<=MAX_POSITIONAL_ARITY;i++)
            if(methodArray[i] != null)
                throw new Exception("Can't have fixed arity function with more params than variadic function");
        }

    IPersistentCollection methods = null;
    for(int i = 0;i<methodArray.length;i++)
        if(methodArray[i] != null)
            methods = RT.cons(methodArray[i], methods);
    if(variadicMethod != null)
        methods = RT.cons(variadicMethod, methods);

    fn.methods = methods;
    fn.variadicMethod = variadicMethod;
    registerFn(fn);
    return fn;
}

static class FnExpr extends AnExpr{
    IPersistentCollection methods;
    FnMethod variadicMethod;
    LocalBinding binding;
    String name = null;
    boolean isCalledDirectly = false;
    //localbinding->itself
    IPersistentMap closes = null;

    String getName(){
        if(name == null)
            {
            if(binding != null)
                name = "FN__" + munge(binding.sym.name) + "__" + RT.nextID();
            else
                name = "FN__" + RT.nextID();
            }
        return name;
    }

    public void emitExpression() throws Exception{
        format("(new ~A(", getName());
        for(ISeq s = RT.seq(closes);s!=null;s=s.rest())
            {
            LocalBinding b = (LocalBinding) ((IMapEntry) s.first()).key();
            format("~A", b.getName());
            if (s.rest() != null)
                format(",");
            }
        format("))");
    }

    public void emitDeclaration() throws Exception {
        PersistentArrayList closesDecls = null;
        if(closes != null)
            {
            closesDecls = new PersistentArrayList(closes.count() * 2);
            for (ISeq s = RT.seq(closes); s != null; s = s.rest())
                {
                LocalBinding b = (LocalBinding) ((IMapEntry) s.first()).key();
                closesDecls.cons(b.typeDeclaration());
                closesDecls.cons(b.getName());
                }
            }
        if(!willBeStaticMethod())
            {
            //emit class declaration
            format("static public class ~A extends ~A{~%",
                   getName(),
                   variadicMethod != null ? "clojure.lang.RestFn" : "AFn");

            if(closes != null)
                {
                //emit members and ctor if closure
                format("~{~A ~A;~%~}", closesDecls);
                format("public ~A (~{~A ~A~^, ~}){~%", getName(), closesDecls);
                if(variadicMethod != null) //must call base ctor
                    format("super(~A);~%", variadicMethod.reqParms.count());
                for (ISeq s = RT.seq(closes); s != null; s = s.rest())
                    {
                    LocalBinding b = (LocalBinding) ((IMapEntry) s.first()).key();
                    format("this.~A = ~A;~%", b.getName(), b.getName());
                    if (s.rest() != null)
                        format(",");
                    }
                format("}~%");
                }
            else if(variadicMethod != null) //must create ctor in order to call base ctor
                {
                format("public ~A (){~%", getName());
                format("super(~A);~%", variadicMethod.reqParms.count());
                format("}~%");
                }

            }
        else
            {
            format("static public Object ~A(~{~A ~A~^, ~}",
                   getName(),
                   closesDecls);
            }

        for(ISeq methods = RT.seq(this.methods);methods != null;methods = methods.rest())
            {
            //this will run once if static method
            FnMethod m = (FnMethod) methods.first();
            if(!willBeStaticMethod())
                 format("public Object ~A(", m.isVariadic()?"doInvoke":"invoke");
            for(ISeq reqs = RT.seq(m.reqParms);reqs != null;reqs = reqs.rest())
                {
                LocalBindingExpr be = (LocalBindingExpr) reqs.first();
                format("Object ~A", be.b.getName());
                if(be.b.needsBox())
                    format("__arg");
                if(reqs.rest() != null)
                    format(",");
                }
            if(m.isVariadic())
                {
                if(m.reqParms.count() > 0)
                    format(",");
                format("ISeq ");
                if(m.restParm != null)
                    {
                    format("~A", m.restParm.b.getName());
                    if(m.restParm.b.needsBox())
                        format("__arg");
                    }
                else
                    format("__keys");
                }
            format(") throws Exception{~%");

            //emit declarations for any boxed args
            for(ISeq reqs = RT.seq(m.reqParms);reqs != null;reqs = reqs.rest())
                {
                LocalBindingExpr be = (LocalBindingExpr) reqs.first();
                if(be.b.needsBox())
                    be.b.emitDeclaration(be.b.getName() + "__arg");
                }
            //emit declaration for any boxed rest arg
            if(m.restParm != null && m.restParm.b.needsBox())
                m.restParm.b.emitDeclaration(m.restParm.b.getName() + "__arg");
            //keys are locals, plucked out of rest arg
            if(m.keyParms != null)
                {
                format("ISeq __valseq = null;~%");
                for (ISeq keys = RT.seq(m.keyParms); keys != null; keys = keys.rest())
                    {
                    KeyParam key = (KeyParam) keys.first();
                    KeywordExpr kw = registerKeyword((Keyword) Symbol.intern(":" + key.bindingExpression.b.sym.name));
                    format("__valseq = RT.findKey(~A,__keys);~%", kw.emitExpressionString());
                    key.bindingExpression.b.emitDeclaration(
                            (String) RT.format(null, "(__valseq!=null)?clojure.lang.RT.first(__valseq):~A"
                                    , key.init.emitExpressionString()));
                    }
                }

            //local variables
            for (ISeq locals = RT.seq(m.locals); locals != null; locals = locals.rest())
                {
                LocalBinding b = (LocalBinding) ((IMapEntry) locals.first()).key();
                if(!b.isParam)
                    b.emitDeclaration("null");
                }

            m.body.emitReturn();
            //end of function
            format("}~%");
            }

        //end of class
        if(!willBeStaticMethod())
            format("}~%");
    }

    boolean willBeStaticMethod() {
        return variadicMethod == null
               && methods.count() == 1
               &&
               (
                       isCalledDirectly
                       ||
                       (binding != null && !binding.isClosed && !binding.valueTaken)
               );
    }
}

static class FnMethod {
    FnMethod parent = null;
    //localbinding->localbinding
    IPersistentMap locals = null;
    //localbinding->localbinding
    PersistentArrayList reqParms = new PersistentArrayList(4);
    PersistentArrayList keyParms = null;
    LocalBindingExpr restParm = null;
    Expr body = null;
    FnExpr fn;

    public FnMethod(FnExpr fn,FnMethod parent) {
        this.parent = parent;
        this.fn = fn;
    }

    boolean isVariadic(){
        return keyParms != null || restParm != null;
    }
}

enum PSTATE{REQ,REST,KEY,DONE}

private static FnMethod analyzeMethod(FnExpr fn,ISeq form) throws Exception {
    //((args) body)
    ISeq parms = (ISeq) RT.first(form);
    ISeq body = RT.rest(form);
    try
        {
        FnMethod method = new FnMethod(fn,(FnMethod) METHOD.getValue());
        METHOD.pushThreadBinding(method);
        LOCAL_ENV.pushThreadBinding(LOCAL_ENV.getValue());
        PSTATE state = PSTATE.REQ;
        for (ISeq ps = parms; ps != null; ps = ps.rest())
            {
            Object p = ps.first();
            if (p == _AM_REST)
                {
                if (state == PSTATE.REQ)
                    state = PSTATE.REST;
                else
                    throw new Exception("Invalid parameter list");
                }
            else if (p == _AM_KEY)
                {
                if (state == PSTATE.REQ)
                    {
                    state = PSTATE.KEY;
                    method.keyParms = new PersistentArrayList(4);
                    }
                else
                    throw new Exception("Invalid parameter list");
                }
            else
                {
                switch (state)
                    {
                    case REQ:
                        method.reqParms = method.reqParms.cons(createParamBinding((Symbol) p));
                        break;
                    case REST:
                        method.restParm = createParamBinding((Symbol) p);
                        state = PSTATE.DONE;
                        break;
                    case KEY:
                        if(p instanceof ISeq)
                            method.keyParms = method.keyParms.cons(
                                        new KeyParam(createParamBinding((Symbol) RT.first(p)),
                                                     analyze(C.EXPRESSION, RT.second(p))));
                        else
                            method.keyParms = method.keyParms.cons(
                                        new KeyParam(createParamBinding((Symbol) p)));

                        break;
                    default:
                        throw new Exception("Unexpected parameter");
                    }
                }
            }
        if(method.reqParms.count() > MAX_POSITIONAL_ARITY)
            throw new Exception("Sorry, can't specify more than " + MAX_POSITIONAL_ARITY + " params");
        method.body = analyze(C.RETURN, RT.cons(DO, body));
        return method;
        }
    finally{
        METHOD.popThreadBinding();
        LOCAL_ENV.popThreadBinding();
    }
}



static LocalBindingExpr createParamBinding(Symbol p) {
    Symbol basep = baseSymbol(p);
    LocalBinding b = new LocalBinding(basep);
    b.isParam = true;
    String typeHint = typeHint(p);
    b.typeHint = typeHint;
    registerLocal(b);
    return new LocalBindingExpr(b, typeHint);
}

private static Expr analyzeDef(C context, ISeq form) throws Exception {
    //(def x) or (def x initexpr)
    if(form.count() > 3)
        throw new Exception("Too many arguments to def");
    Symbol sym = (Symbol) RT.second(form);
    Module module = (Module) _CT_MODULE.getValue();
    Var var = module.intern(baseSymbol(sym));
    registerVar(var);
    VarExpr ve = new VarExpr(var, typeHint(sym));
    Expr init = analyze(C.EXPRESSION, macroexpand(RT.third(form)));
    if(init instanceof FnExpr)
        ((FnExpr)init).name = "FN__" + munge(var.name.toString()) + "__" + RT.nextID();

    return new DefExpr(ve, init);
}

static Symbol baseSymbol(Symbol sym) {
    String base = baseName(sym);

    if(base == sym.name) //no typeHint
        return sym;

    return Symbol.intern(base);
}

static String baseName(Symbol sym){
    int slash = sym.name.indexOf('/');
    if(slash > 0)
       return sym.name.substring(0, slash);
    return sym.name;
}

static String typeHint(Symbol sym){
    int slash = sym.name.indexOf('/');
    if(slash > 0)
       return sym.name.substring(slash + 1);
    return null;
}

private static Expr analyzeSymbol(Symbol sym) throws Exception {
    if(sym instanceof Keyword)
        return registerKeyword((Keyword)sym);
    else if(sym instanceof HostSymbol)
        return new HostExpr((HostSymbol)sym);
    else
        {
        String typeHint = typeHint(sym);
        sym = baseSymbol(sym);
        LocalBinding b = referenceLocal(sym);
        if(b != null)
            return new LocalBindingExpr(b, typeHint);
        Var v = lookupVar(sym);
        if(v != null)
            return new VarExpr(v, typeHint);
        throw new Exception("Unable to resolve symbol: " + sym.name + " in this context");
        }
}

static Var lookupVar(Symbol sym){
    Module module = (Module) _CT_MODULE.getValue();
    Var v = module.find(sym);
    if(v != null)
        return v;
    for(ISeq seq = RT.seq(USES.getValue());seq != null;seq = RT.rest(seq))
        {
        module = (Module) ((IMapEntry)RT.first(seq)).key();
        v = module.find(sym);
        if(v != null && !v.hidden)
            return v;
        }
    return null;
}

static Object macroexpand(Object x){
    return x; //placeholder
}

private static KeywordExpr registerKeyword(Keyword keyword) {
    IPersistentMap keywordsMap = (IPersistentMap) KEYWORDS.getValue();
    KeywordExpr ke = (KeywordExpr) RT.get(keyword,keywordsMap);
    if(ke == null)
        KEYWORDS.setValue(RT.assoc(keyword, ke = new KeywordExpr(keyword),keywordsMap));
    return ke;
}

private static void registerVar(Var var) {
    IPersistentMap varsMap = (IPersistentMap) VARS.getValue();
    if(RT.get(var,varsMap) == null)
        VARS.setValue(RT.assoc(var, var, varsMap));
}

private static void registerFn(FnExpr fn) {
    FNS.setValue(RT.cons(fn, (IPersistentCollection) FNS.getValue()));
}

static void closeOver(LocalBinding b,FnMethod method){
    if(b != null && method != null && RT.get(b,method.locals) == null)
        {
        b.isClosed = true;
        method.fn.closes = (IPersistentMap)RT.assoc(b, b, method.fn.closes);
        closeOver(b,method.parent);
        }
}

static LocalBinding referenceLocal(Symbol sym) {
    LocalBinding b = (LocalBinding) RT.get(sym, LOCAL_ENV.getValue());
    closeOver(b,(FnMethod) METHOD.getValue());
    return b;
}

private static void registerLocal(LocalBinding b) {
    IPersistentMap localsMap = (IPersistentMap) LOCAL_ENV.getValue();
    LOCAL_ENV.setValue(RT.assoc(b.sym, b, localsMap));
    FnMethod method = (FnMethod) METHOD.getValue();
    method.locals = (IPersistentMap) RT.assoc(b, b, method.locals);
}
/*
(defun reference-var (sym)
  (let ((b (first (member sym *var-env* :key (lambda (b)
                                               (@ :symbol b))))))
    (labels
        ((check-closed (b frame)
           (when (and b frame
                      (not (member b (@ :local-bindings frame)))) ;closed over
             (setf (@ :closed? b) t)
             (pushnew b (@ :closes frame))
             (check-closed b (@ :parent frame)))))
      (check-closed b *frame*))
    b))
    */

static String resolveHostClassname(String classname) throws Exception {
    if(classname.indexOf('.') != -1)    //presume fully qualified if contains .
        return classname;
    IPersistentMap importMap = (IPersistentMap) IMPORTS.getValue();
    String fullyQualifiedName = (String) RT.get(classname,importMap);
    if(fullyQualifiedName == null)
        throw new Exception("Can't resolve type name: " + classname);
    return fullyQualifiedName;
}



static class KeyParam{
    public KeyParam(LocalBindingExpr b, Expr init) {
        this.bindingExpression = b;
        this.init = init;
        kw = registerKeyword((Keyword) Symbol.intern(":" + bindingExpression.b.sym.name));
    }

    public KeyParam(LocalBindingExpr b) {
        this(b,NIL_EXPR);
    }

    LocalBindingExpr bindingExpression;
    Expr init;
    KeywordExpr kw;
}


static class NilExpr extends AnExpr{
    public void emitExpression() throws Exception{
        format("null");
    }
}

static class LiteralExpr extends AnExpr{
    final Object val;

    public LiteralExpr(Object val){
        this.val = val;
    }

    public void emitExpression() throws Exception{
        format("~S",val);
    }
}

static class NotExpr extends AnExpr{
    final Expr expr;

    public NotExpr(Expr expr){
        this.expr = expr;
    }

}

static class CharExpr extends AnExpr{
    final Character val;

    public CharExpr(Character val){
        this.val = val;
    }

    public void emitExpression() throws Exception{
        format("'~A'",val);
    }
}


static class HostExpr extends AnExpr{
    final HostSymbol sym;

    public HostExpr(HostSymbol sym){
        this.sym = sym;
    }

    public void emitExpression() throws Exception{
        if(sym instanceof ClassSymbol)
            format("~A.class", resolveHostClassname(((ClassSymbol) sym).className));
    }
}
/*
static class SymExpr extends AnExpr{
    Symbol sym;
    String typeHint;

    public SymExpr(Symbol sym, String typeHint){
        this.sym = sym;
        this.typeHint = typeHint;
    }

    public void emitExpression() throws Exception{
        format("~A", munge(sym.name));
    }
}
*/
static class KeywordExpr extends AnExpr{
    final Symbol sym;

    public KeywordExpr(Symbol sym){
        this.sym = sym;
    }

    public void emitExpression() throws Exception {
        format("~A", munge(sym.name));
    }
}

static class LocalBinding{
    final Symbol sym;
    boolean isClosed = false;
    boolean isParam = false;
    final int id = RT.nextID();
    String typeHint;
    public boolean valueTaken = false;
    boolean isAssigned = false;


    public LocalBinding(Symbol sym) {
        this.sym = sym;
    }

    public String getName(){
        return munge(sym.name) + (isParam?"":("__" + id));
    }

    boolean needsBox(){
        return isClosed && isAssigned;
    }

    String typeDeclaration(){
        if(needsBox())
            return "clojure.lang.Box";
        return "Object";
    }

    void emitDeclaration(String init) throws Exception {
        format("~A ~A = ", typeDeclaration(), getName());
        if(needsBox())
            format("new clojure.lang.Box(~A);~%", init);
        else
            format("~A;~%", init);
    }
}

static class LocalBindingExpr extends AnExpr{
    final LocalBinding b;
    final String typeHint;

    public LocalBindingExpr(LocalBinding b, String typeHint){
        this.b = b;
        this.typeHint = typeHint;
    }

    public void emitExpression() throws Exception{
        format("~A", b.getName());
    }
}

static class VarExpr extends AnExpr{
    final Var var;
    final String typeHint;

    public VarExpr(Var var, String typeHint){
        this.var = var;
        this.typeHint = typeHint;
    }

    public void emitExpression() throws Exception{
        format("~A", munge(var.toString()));
    }
}

static class DefExpr extends AnExpr{
    final VarExpr var;
    final Expr init;

    public DefExpr(VarExpr var, Expr init){
        this.var = var;
        this.init = init;
    }

    public void emitExpression() throws Exception{
        format("~A.bind(~A)", var.emitExpressionString(),init.emitExpressionString());
    }
}

public static void main(String[] args) throws Exception {
    if(!(args.length >= 3 ))
        System.err.println("Usage: clojure.lang.Compiler package class file1 [file2 ...]");
    String pkg = args[0];
    String classname = args[1];
    LineNumberingPushbackReader[] rs = new LineNumberingPushbackReader[args.length - 2];
    String ret;
    try
        {
        for(int i=0;i<rs.length;i++)
            {
            rs[i] = new LineNumberingPushbackReader(new InputStreamReader(new FileInputStream(args[i + 2])));
            }
        ret = compile(pkg, classname, rs);
        System.out.print(ret);
        }
    finally
        {
        for (LineNumberingPushbackReader r : rs)
            {
            if(r != null)
                r.close();
            }
        }
}

}
//*/


